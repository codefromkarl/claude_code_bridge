#!/usr/bin/env python3
"""
cpend - View latest Codex reply
"""

import json
import os
import sys
from pathlib import Path

script_dir = Path(__file__).resolve().parent
lib_dir = script_dir.parent / "lib"
sys.path.insert(0, str(lib_dir))
from compat import setup_windows_encoding
setup_windows_encoding()

from i18n import t
from task_utils import get_latest_task_output
from ccb_config import send_notification

try:
    from cli_output import EXIT_ERROR, EXIT_NO_REPLY, EXIT_OK
    from codex_comm import CodexLogReader
except ImportError as exc:
    print(f"Import failed: {exc}")
    sys.exit(1)

def _debug_enabled() -> bool:
    return (os.environ.get("CCB_DEBUG") in ("1", "true", "yes")) or (os.environ.get("CPEND_DEBUG") in ("1", "true", "yes"))


def _debug(message: str) -> None:
    if not _debug_enabled():
        return
    print(f"[DEBUG] {message}", file=sys.stderr)


def _load_session_log_path() -> Path | None:
    """Load codex_session_path from .codex-session if exists"""
    session_file = Path.cwd() / ".codex-session"
    if not session_file.exists():
        return None
    try:
        with session_file.open("r", encoding="utf-8-sig") as f:
            data = json.load(f)
        path_str = data.get("codex_session_path")
        if path_str:
            return Path(path_str).expanduser()
    except Exception as exc:
        _debug(f"Failed to read .codex-session ({session_file}): {exc}")
    return None

def _parse_n(argv: list[str]) -> int:
    if len(argv) <= 1:
        return 1
    if argv[1] in ("-h", "--help"):
        print("Usage: cpend [N]", file=sys.stderr)
        raise SystemExit(EXIT_OK)
    try:
        n = int(argv[1])
    except ValueError:
        print("Usage: cpend [N]", file=sys.stderr)
        raise SystemExit(EXIT_ERROR)
    return max(1, n)


def main(argv: list[str]) -> int:
    try:
        n = _parse_n(argv)

        # Try session-specific log path first, fallback to scanning latest
        log_path = _load_session_log_path()
        if log_path:
            _debug(f"Using codex_session_path from .codex-session: {log_path}")
        reader = CodexLogReader(log_path=log_path)

        # If specified log has no reply, try scanning for latest
        if log_path and log_path.exists():
            test_msg = reader.latest_message()
            if not test_msg:
                # Scan for latest log that might have replies
                latest = reader._scan_latest()
                if latest and latest != log_path:
                    reader.set_preferred_log(latest)
                    log_path = latest
                    _debug(f"Preferred log had no reply; switching to latest: {log_path}")

        if n > 1:
            conversations = reader.latest_conversations(n)
            if not conversations:
                print(t("no_reply_available", provider="Codex"), file=sys.stderr)
                return EXIT_NO_REPLY
            for i, (question, reply) in enumerate(conversations):
                if question:
                    print(f"Q: {question}")
                print(f"A: {reply}")
                if i < len(conversations) - 1:
                    print("---")
            task_out = get_latest_task_output()
            if task_out:
                print("\n[Task Output]")
                print(task_out)
            return EXIT_OK

        message = reader.latest_message()
        if not message:
            print(t("no_reply_available", provider="Codex"), file=sys.stderr)
            return EXIT_NO_REPLY
        print(message)
        send_notification("CCB: Codex Reply", message[:100] + ("..." if len(message) > 100 else ""))
        task_out = get_latest_task_output()
        if task_out:
            print("\n[Task Output]")
            print(task_out)
        return EXIT_OK
    except Exception as exc:
        if _debug_enabled():
            import traceback

            traceback.print_exc()
        print(f"[ERROR] {t('execution_failed', error=exc)}", file=sys.stderr)
        return EXIT_ERROR


if __name__ == "__main__":
    sys.exit(main(sys.argv))
